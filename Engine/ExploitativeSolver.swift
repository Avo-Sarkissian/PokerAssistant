import Foundation

class ExploitativeSolver {
    
    // MARK: - Position
    
    enum Position {
        case inPosition      // Button - act last, best position
        case outOfPosition   // SB/BB - act first, worst position
        
        init(from positionString: String) {
            if positionString == "Btn" {
                self = .inPosition
            } else {
                self = .outOfPosition
            }
        }
        
        // Position multiplier for aggression
        var aggressionMultiplier: Double {
            switch self {
            case .inPosition: return 1.15      // Can be more aggressive IP
            case .outOfPosition: return 0.85  // More conservative OOP
            }
        }
        
        // Position affects how wide we can bluff
        var bluffFrequencyMultiplier: Double {
            switch self {
            case .inPosition: return 1.2      // Can bluff more IP
            case .outOfPosition: return 0.7   // Bluff less OOP
            }
        }
        
        // Position affects calling range
        var callingRangeMultiplier: Double {
            switch self {
            case .inPosition: return 1.1      // Can call wider IP
            case .outOfPosition: return 0.9   // Call tighter OOP
            }
        }
    }
    
    // MARK: - Opponent Modeling
    
    enum OpponentRange {
        case tight      // Top 15% - only premium hands
        case standard   // Top 30% - solid range
        case loose      // Top 50% - wide range
        case veryLoose  // Top 70% - playing too many hands
        
        var foldToCBet: Double {
            switch self {
            case .tight: return 0.35
            case .standard: return 0.50
            case .loose: return 0.60
            case .veryLoose: return 0.70
            }
        }
        
        var foldToRaise: Double {
            switch self {
            case .tight: return 0.25
            case .standard: return 0.40
            case .loose: return 0.55
            case .veryLoose: return 0.65
            }
        }
    }
    
    // MARK: - Hand Strength Categories
    
    enum HandStrength {
        case monster    // 85%+ equity
        case strong     // 70-85% equity
        case medium     // 50-70% equity
        case weak       // 35-50% equity
        case bluff      // <35% equity
        
        init(equity: Double) {
            switch equity {
            case 0.85...: self = .monster
            case 0.70..<0.85: self = .strong
            case 0.50..<0.70: self = .medium
            case 0.35..<0.50: self = .weak
            default: self = .bluff
            }
        }
    }
    
    // MARK: - Main Solve Function
    
    func solve(gameState: GameState, myEquity: Double, settings: Settings) async -> CalculationResult.RecommendedAction {
        let street = determineStreet(gameState: gameState)
        let position = Position(from: gameState.position)
        let spr = calculateSPR(gameState: gameState, settings: settings)
        let potOdds = calculatePotOdds(gameState: gameState)
        let handStrength = HandStrength(equity: myEquity)
        let opponentRange = profileOpponent(gameState: gameState, street: street)
        
        // Calculate EVs for each action
        let evFold = 0.0
        let evCall = calculateCallEV(equity: myEquity, gameState: gameState, position: position)
        let (evRaise, raiseAmount) = calculateRaiseEV(
            equity: myEquity,
            handStrength: handStrength,
            gameState: gameState,
            settings: settings,
            spr: spr,
            street: street,
            opponentRange: opponentRange,
            position: position
        )
        
        // Decision logic with sanity checks
        return makeDecision(
            evFold: evFold,
            evCall: evCall,
            evRaise: evRaise,
            raiseAmount: raiseAmount,
            equity: myEquity,
            potOdds: potOdds,
            handStrength: handStrength,
            spr: spr,
            street: street,
            position: position,
            gameState: gameState
        )
    }
    
    // MARK: - Street Detection
    
    private func determineStreet(gameState: GameState) -> Street {
        let communityCount = gameState.communityCards.compactMap { $0 }.count
        switch communityCount {
        case 0: return .preflop
        case 3: return .flop
        case 4: return .turn
        case 5: return .river
        default: return .preflop
        }
    }
    
    // MARK: - Stack-to-Pot Ratio
    
    private func calculateSPR(gameState: GameState, settings: Settings) -> Double {
        let effectivePot = max(gameState.potSize, settings.bigBlind)
        return gameState.stack / effectivePot
    }
    
    // MARK: - Pot Odds
    
    private func calculatePotOdds(gameState: GameState) -> Double {
        guard gameState.toCall > 0 else { return 0 }
        return gameState.toCall / (gameState.potSize + gameState.toCall)
    }
    
    // MARK: - Opponent Profiling
    
    private func profileOpponent(gameState: GameState, street: Street) -> OpponentRange {
        let potRelativeBet = gameState.toCall / max(gameState.potSize, 1)
        
        switch street {
        case .preflop:
            if potRelativeBet > 0.5 { return .tight }
            if potRelativeBet > 0.2 { return .standard }
            return .loose
            
        case .flop:
            if potRelativeBet > 0.8 { return .tight }
            if potRelativeBet > 0.5 { return .standard }
            return .loose
            
        case .turn:
            if potRelativeBet > 0.7 { return .tight }
            if potRelativeBet > 0.4 { return .standard }
            return .loose
            
        case .river:
            if potRelativeBet > 0.6 { return .tight }
            if potRelativeBet > 0.3 { return .standard }
            return .loose
        }
    }
    
    // MARK: - EV Calculations
    
    private func calculateCallEV(equity: Double, gameState: GameState, position: Position) -> Double {
        let potAfterCall = gameState.potSize + gameState.toCall
        var ev = (equity * potAfterCall) - gameState.toCall
        
        // Position adjustment: being in position has implied odds value
        ev *= position.callingRangeMultiplier
        
        return ev
    }
    
    private func calculateRaiseEV(
        equity: Double,
        handStrength: HandStrength,
        gameState: GameState,
        settings: Settings,
        spr: Double,
        street: Street,
        opponentRange: OpponentRange,
        position: Position
    ) -> (ev: Double, amount: Double) {
        
        let raiseAmount = calculateOptimalRaiseSize(
            handStrength: handStrength,
            gameState: gameState,
            settings: settings,
            spr: spr,
            street: street,
            position: position
        )
        
        let effectiveRaise = min(raiseAmount, gameState.stack)
        
        // Fold equity is higher when in position
        var foldEquity = opponentRange.foldToRaise
        if handStrength == .bluff || handStrength == .weak {
            foldEquity *= position.bluffFrequencyMultiplier
        }
        foldEquity = min(foldEquity, 0.80)  // Cap at 80%
        
        let potWhenFolded = gameState.potSize
        let costToRaise = gameState.toCall + effectiveRaise
        let potIfCalled = gameState.potSize + costToRaise + effectiveRaise
        let evWhenCalled = (equity * potIfCalled) - costToRaise
        
        var ev = (foldEquity * potWhenFolded) + ((1 - foldEquity) * evWhenCalled)
        
        // Position bonus for raising
        ev *= position.aggressionMultiplier
        
        return (ev, effectiveRaise)
    }
    
    // MARK: - Raise Sizing
    
    private func calculateOptimalRaiseSize(
        handStrength: HandStrength,
        gameState: GameState,
        settings: Settings,
        spr: Double,
        street: Street,
        position: Position
    ) -> Double {
        
        let pot = gameState.potSize
        let toCall = gameState.toCall
        
        // Base sizing as percentage of pot based on hand strength
        var baseSizingPercent: Double
        switch handStrength {
        case .monster:
            baseSizingPercent = 0.75
        case .strong:
            baseSizingPercent = 0.60
        case .medium:
            baseSizingPercent = 0.45
        case .weak:
            baseSizingPercent = 0.33
        case .bluff:
            baseSizingPercent = 0.40
        }
        
        // Position adjustment: can size smaller in position (more control)
        if position == .inPosition {
            baseSizingPercent *= 0.9  // Slightly smaller bets IP
        } else {
            baseSizingPercent *= 1.1  // Slightly larger bets OOP for protection
        }
        
        // SPR adjustment
        let sprAdjustment: Double
        if spr < 2 {
            sprAdjustment = 2.0
        } else if spr < 4 {
            sprAdjustment = 1.3
        } else if spr < 8 {
            sprAdjustment = 1.0
        } else {
            sprAdjustment = 0.9
        }
        
        // Street adjustment
        let streetMultiplier: Double
        switch street {
        case .preflop: streetMultiplier = 1.0
        case .flop: streetMultiplier = 1.0
        case .turn: streetMultiplier = 1.1
        case .river: streetMultiplier = 1.2
        }
        
        var raiseAmount = pot * baseSizingPercent * sprAdjustment * streetMultiplier
        
        // Minimum raise is the big blind
        let minRaise = settings.bigBlind
        raiseAmount = max(raiseAmount, minRaise)
        
        // Cap at pot unless monster
        if handStrength != .monster {
            raiseAmount = min(raiseAmount, pot * 1.0)
        }
        
        return roundToSmallBlind(raiseAmount, smallBlind: settings.smallBlind)
    }
    
    // MARK: - Decision Logic
    
    private func makeDecision(
        evFold: Double,
        evCall: Double,
        evRaise: Double,
        raiseAmount: Double,
        equity: Double,
        potOdds: Double,
        handStrength: HandStrength,
        spr: Double,
        street: Street,
        position: Position,
        gameState: GameState
    ) -> CalculationResult.RecommendedAction {
        
        // Sanity check 1: If equity is below pot odds needed, fold (can't profitably continue)
        if gameState.toCall > 0 {
            let potOddsNeeded = gameState.toCall / (gameState.potSize + gameState.toCall)
            if equity < potOddsNeeded {
                // We don't have the odds to call, and raising as a bluff with a trash hand is -EV
                // Exception: Strong draws might semi-bluff, but handStrength check handles that
                if handStrength == .weak || handStrength == .bluff || equity < 0.25 {
                    return .fold
                }
            }
        }

        // Sanity check 1b: Never bet trash when checking is free
        // With <30% equity, you're likely behind - don't build a pot you'll lose
        if equity < 0.30 && gameState.toCall == 0 {
            return .call  // Check
        }

        // Sanity check 2: Don't bluff out of position with weak hands
        if position == .outOfPosition && (handStrength == .bluff || handStrength == .weak) {
            if raiseAmount > gameState.stack * 0.2 {
                if evCall > 0 { return .call }
                if gameState.toCall == 0 { return .call }  // Check
                return .fold
            }
        }
        
        // Sanity check 3: Don't raise weak hands for large amounts
        if handStrength == .weak || handStrength == .bluff {
            if raiseAmount > gameState.stack * 0.3 {
                if evCall > 0 { return .call }
                if gameState.toCall == 0 { return .call }  // Check
                return .fold
            }
        }
        
        // Sanity check 4: With medium hands, prefer calling over large raises
        if handStrength == .medium {
            if raiseAmount > gameState.potSize * 0.5 && evCall > 0 {
                return .call
            }
        }
        
        // Sanity check 5: Low SPR with non-monster hands
        if spr < 3 && handStrength != .monster && handStrength != .strong {
            if evCall > 0 { return .call }
            if evCall > -gameState.toCall * 0.2 { return .call }
            if gameState.toCall == 0 { return .call }  // Check
            return .fold
        }
        
        // Sanity check 6: Check is free - don't bet weak hands OOP
        if gameState.toCall == 0 && position == .outOfPosition {
            if handStrength == .weak || handStrength == .bluff {
                if evRaise <= evCall * 1.2 {  // Need significant EV advantage to bet
                    return .call  // Check
                }
            }
        }
        
        // Standard decision: pick highest EV action
        if evRaise > evCall && evRaise > evFold && evRaise > 0 {
            return .raise(amount: raiseAmount)
        } else if evCall >= evFold && evCall > -0.5 {
            return .call
        } else if gameState.toCall == 0 {
            return .call  // Always check if free
        } else {
            return .fold
        }
    }
    
    // MARK: - Helpers
    
    private func roundToSmallBlind(_ amount: Double, smallBlind: Double) -> Double {
        guard smallBlind > 0 else { return amount }
        return round(amount / smallBlind) * smallBlind
    }
}
