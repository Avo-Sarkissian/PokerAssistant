import Foundation

class ExploitativeSolver {
    
    // MARK: - Position

    enum Position {
        case btn          // Button - best position (in position)
        case sb           // Small Blind (out of position)
        case bb           // Big Blind (out of position)

        init(from positionString: String) {
            switch positionString {
            case "BTN": self = .btn
            case "SB": self = .sb
            case "BB": self = .bb
            default: self = .btn  // Default to button
            }
        }

        // Position multiplier for aggression (higher = more aggressive)
        var aggressionMultiplier: Double {
            switch self {
            case .btn: return 1.20    // Most aggressive - in position
            case .sb: return 0.80     // Conservative OOP
            case .bb: return 0.90     // Slightly conservative
            }
        }

        // Position affects how wide we can bluff
        var bluffFrequencyMultiplier: Double {
            switch self {
            case .btn: return 1.3     // Can bluff more in position
            case .sb: return 0.6      // Hard to bluff OOP
            case .bb: return 0.7      // Limited bluffs
            }
        }

        // Position affects calling range
        var callingRangeMultiplier: Double {
            switch self {
            case .btn: return 1.15    // Can call wider in position
            case .sb: return 0.85     // Call tight OOP
            case .bb: return 0.95     // Slightly tight
            }
        }

        // Whether position is "in position" post-flop (acts last)
        var isInPosition: Bool {
            switch self {
            case .btn: return true
            case .sb, .bb: return false
            }
        }

        // Opening range percentile (for pre-flop first to act)
        var openingRangePercentile: Double {
            switch self {
            case .btn: return 0.45    // Top 45% - wide
            case .sb: return 0.35     // Top 35% (vs BB only)
            case .bb: return 0.50     // Top 50% (defending)
            }
        }
    }
    
    // MARK: - Opponent Modeling
    // Using OpponentRange.RangeType from OpponentRange.swift
    
    // MARK: - Hand Strength Categories

    enum HandStrength {
        case monster    // Premium hands (AA, KK, QQ, AKs, JJ) or 85%+ equity
        case strong     // Strong hands (TT, AK, AQs, etc.) or 70-85% equity
        case medium     // Playable hands or 50-70% equity
        case weak       // Marginal hands or 35-50% equity
        case bluff      // Trash hands or <35% equity

        /// Equity-based init (for post-flop)
        init(equity: Double) {
            switch equity {
            case 0.85...: self = .monster
            case 0.70..<0.85: self = .strong
            case 0.50..<0.70: self = .medium
            case 0.35..<0.50: self = .weak
            default: self = .bluff
            }
        }

        /// Preflop hand ranking based init (uses hand rankings, not raw equity)
        /// This is important because AA has ~50% equity vs 5 opponents but is still premium
        init(preflopRanking: Int, equity: Double) {
            // Hand rankings: 0 = AA, 4 = JJ, 12 = AQo, etc.
            switch preflopRanking {
            case 0...4:     // AA, KK, QQ, AKs, JJ
                self = .monster
            case 5...12:    // AQs, TT, AKo, AJs, KQs, 99, ATs, AQo
                self = .strong
            case 13...45:   // Good playable hands
                self = .medium
            case 46...75:   // Marginal hands
                self = .weak
            default:        // Trash
                // But if equity is decent post-flop, upgrade
                if equity >= 0.50 {
                    self = .medium
                } else if equity >= 0.35 {
                    self = .weak
                } else {
                    self = .bluff
                }
            }
        }
    }
    
    // MARK: - Main Solve Function
    
    func solve(gameState: GameState, myEquity: Double, settings: Settings) async -> CalculationResult.RecommendedAction {
        let street = determineStreet(gameState: gameState)
        let position = Position(from: gameState.position)
        let spr = calculateSPR(gameState: gameState, settings: settings)
        let potOdds = calculatePotOdds(gameState: gameState)
        let opponentRange = profileOpponent(gameState: gameState, street: street)

        // Determine hand strength - use preflop rankings for preflop, equity for post-flop
        let handStrength: HandStrength
        if street == .preflop, let card1 = gameState.holeCards[0], let card2 = gameState.holeCards[1] {
            let ranking = OpponentRange.handStrength(card1, card2)
            handStrength = HandStrength(preflopRanking: ranking, equity: myEquity)
        } else {
            handStrength = HandStrength(equity: myEquity)
        }
        
        // Calculate EVs for each action
        let evFold = 0.0
        let evCall = calculateCallEV(equity: myEquity, gameState: gameState, position: position)
        let (evRaise, raiseAmount) = calculateRaiseEV(
            equity: myEquity,
            handStrength: handStrength,
            gameState: gameState,
            settings: settings,
            spr: spr,
            street: street,
            opponentRange: opponentRange,
            position: position
        )
        
        // Decision logic with sanity checks
        return makeDecision(
            evFold: evFold,
            evCall: evCall,
            evRaise: evRaise,
            raiseAmount: raiseAmount,
            equity: myEquity,
            potOdds: potOdds,
            handStrength: handStrength,
            spr: spr,
            street: street,
            position: position,
            gameState: gameState
        )
    }
    
    // MARK: - Street Detection
    
    private func determineStreet(gameState: GameState) -> Street {
        let communityCount = gameState.communityCards.compactMap { $0 }.count
        switch communityCount {
        case 0: return .preflop
        case 3: return .flop
        case 4: return .turn
        case 5: return .river
        default: return .preflop
        }
    }
    
    // MARK: - Stack-to-Pot Ratio
    
    private func calculateSPR(gameState: GameState, settings: Settings) -> Double {
        let effectivePot = max(gameState.potSize, settings.bigBlind)
        return gameState.stack / effectivePot
    }
    
    // MARK: - Pot Odds
    
    private func calculatePotOdds(gameState: GameState) -> Double {
        guard gameState.toCall > 0 else { return 0 }
        return gameState.toCall / (gameState.potSize + gameState.toCall)
    }
    
    // MARK: - Opponent Profiling
    
    private func profileOpponent(gameState: GameState, street: Street) -> OpponentRange.RangeType {
        let potRelativeBet = gameState.toCall / max(gameState.potSize, 1)

        // Use the consolidated OpponentRange logic
        return OpponentRange.rangeFromAction(
            potRelativeBet: potRelativeBet,
            street: street,
            isRaise: gameState.toCall > 0
        )
    }

    // Fold equity estimation based on opponent range type
    private func foldEquityForRange(_ range: OpponentRange.RangeType) -> Double {
        switch range {
        case .veryTight: return 0.25   // Premium hands rarely fold
        case .tight: return 0.35       // Strong range
        case .standard: return 0.45    // Solid range
        case .wide: return 0.55        // Loose range
        case .veryWide: return 0.65    // Very loose
        case .random: return 0.50      // Unknown
        }
    }
    
    // MARK: - EV Calculations
    
    private func calculateCallEV(equity: Double, gameState: GameState, position: Position) -> Double {
        let potAfterCall = gameState.potSize + gameState.toCall
        var ev = (equity * potAfterCall) - gameState.toCall
        
        // Position adjustment: being in position has implied odds value
        ev *= position.callingRangeMultiplier
        
        return ev
    }
    
    private func calculateRaiseEV(
        equity: Double,
        handStrength: HandStrength,
        gameState: GameState,
        settings: Settings,
        spr: Double,
        street: Street,
        opponentRange: OpponentRange.RangeType,
        position: Position
    ) -> (ev: Double, amount: Double) {

        let raiseAmount = calculateOptimalRaiseSize(
            handStrength: handStrength,
            gameState: gameState,
            settings: settings,
            spr: spr,
            street: street,
            position: position
        )

        let effectiveRaise = min(raiseAmount, gameState.stack)

        // Fold equity is higher when in position
        var foldEquity = foldEquityForRange(opponentRange)
        if handStrength == .bluff || handStrength == .weak {
            foldEquity *= position.bluffFrequencyMultiplier
        }
        foldEquity = min(foldEquity, 0.80)  // Cap at 80%
        
        let potWhenFolded = gameState.potSize
        let costToRaise = gameState.toCall + effectiveRaise
        let potIfCalled = gameState.potSize + costToRaise + effectiveRaise
        let evWhenCalled = (equity * potIfCalled) - costToRaise
        
        var ev = (foldEquity * potWhenFolded) + ((1 - foldEquity) * evWhenCalled)
        
        // Position bonus for raising
        ev *= position.aggressionMultiplier
        
        return (ev, effectiveRaise)
    }
    
    // MARK: - Raise Sizing
    
    private func calculateOptimalRaiseSize(
        handStrength: HandStrength,
        gameState: GameState,
        settings: Settings,
        spr: Double,
        street: Street,
        position: Position
    ) -> Double {
        
        let pot = gameState.potSize
        let toCall = gameState.toCall
        
        // Base sizing as percentage of pot based on hand strength
        var baseSizingPercent: Double
        switch handStrength {
        case .monster:
            baseSizingPercent = 0.75
        case .strong:
            baseSizingPercent = 0.60
        case .medium:
            baseSizingPercent = 0.45
        case .weak:
            baseSizingPercent = 0.33
        case .bluff:
            baseSizingPercent = 0.40
        }
        
        // Position adjustment: can size smaller in position (more control)
        if position.isInPosition {
            baseSizingPercent *= 0.9  // Slightly smaller bets IP
        } else {
            baseSizingPercent *= 1.1  // Slightly larger bets OOP for protection
        }
        
        // SPR adjustment
        let sprAdjustment: Double
        if spr < 2 {
            sprAdjustment = 2.0
        } else if spr < 4 {
            sprAdjustment = 1.3
        } else if spr < 8 {
            sprAdjustment = 1.0
        } else {
            sprAdjustment = 0.9
        }
        
        // Street adjustment
        let streetMultiplier: Double
        switch street {
        case .preflop: streetMultiplier = 1.0
        case .flop: streetMultiplier = 1.0
        case .turn: streetMultiplier = 1.1
        case .river: streetMultiplier = 1.2
        }
        
        var raiseAmount = pot * baseSizingPercent * sprAdjustment * streetMultiplier
        
        // Minimum raise is the big blind
        let minRaise = settings.bigBlind
        raiseAmount = max(raiseAmount, minRaise)
        
        // Cap at pot unless monster
        if handStrength != .monster {
            raiseAmount = min(raiseAmount, pot * 1.0)
        }
        
        return roundToSmallBlind(raiseAmount, smallBlind: settings.smallBlind)
    }
    
    // MARK: - Decision Logic
    
    private func makeDecision(
        evFold: Double,
        evCall: Double,
        evRaise: Double,
        raiseAmount: Double,
        equity: Double,
        potOdds: Double,
        handStrength: HandStrength,
        spr: Double,
        street: Street,
        position: Position,
        gameState: GameState
    ) -> CalculationResult.RecommendedAction {

        // ============================================================
        // ABSOLUTE RULE: Never fold when checking is free
        // ============================================================
        if gameState.toCall == 0 {
            // Only decide between check and bet - folding is never correct
            // Bet with strong hands, check with weak hands
            if handStrength == .monster || handStrength == .strong {
                return .raise(amount: raiseAmount)
            } else if handStrength == .medium && evRaise > 0 && position.isInPosition {
                return .raise(amount: raiseAmount)
            } else {
                return .call  // Check
            }
        }

        // ============================================================
        // With a bet to face, evaluate properly
        // ============================================================

        // Premium hands should almost always raise preflop
        if street == .preflop && (handStrength == .monster || handStrength == .strong) {
            return .raise(amount: raiseAmount)
        }

        // Calculate pot odds needed
        let potOddsNeeded = gameState.toCall / (gameState.potSize + gameState.toCall)

        // If equity is below pot odds AND we have a weak/bluff hand, fold
        if equity < potOddsNeeded && (handStrength == .weak || handStrength == .bluff) {
            return .fold
        }

        // Medium hands - can raise for value/fold equity even when calling isn't profitable
        if handStrength == .medium {
            // Always consider raising first - fold equity makes raising better than calling
            // Especially from BTN with playable hands like QJs, KTs, etc.
            if evRaise > 0 && evRaise > evCall {
                return .raise(amount: raiseAmount)
            }

            if equity >= potOddsNeeded {
                // We have the odds to call
                return .call
            } else {
                // Below pot odds - call if close, else fold
                if equity > potOddsNeeded * 0.75 {
                    return .call
                }
                return .fold
            }
        }

        // Strong/monster hands should raise
        if handStrength == .monster || handStrength == .strong {
            return .raise(amount: raiseAmount)
        }

        // Weak hands - call if odds are right, else fold
        if handStrength == .weak {
            if equity >= potOddsNeeded {
                return .call
            }
            return .fold
        }

        // Bluff hands - mostly fold, occasionally bluff if in position with fold equity
        if handStrength == .bluff {
            if position.isInPosition && evRaise > 0 && equity > 0.20 {
                return .raise(amount: raiseAmount)  // Semi-bluff
            }
            return .fold
        }

        // Default: use EV comparison
        if evRaise > evCall && evRaise > 0 {
            return .raise(amount: raiseAmount)
        } else if evCall > 0 {
            return .call
        } else {
            return .fold
        }
    }
    
    // MARK: - Helpers
    
    private func roundToSmallBlind(_ amount: Double, smallBlind: Double) -> Double {
        guard smallBlind > 0 else { return amount }
        return round(amount / smallBlind) * smallBlind
    }
}
